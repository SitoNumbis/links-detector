/// <reference lib="webworker" />

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim, skipWaiting } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// eslint-disable-next-line no-undef
declare const self: ServiceWorkerGlobalScope;

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA

// @ts-ignore
// eslint-disable-next-line max-len
// eslint-disable-next-line no-restricted-globals, no-underscore-dangle, @typescript-eslint/no-unused-vars
const ignored = self.__WB_MANIFEST;

const CACHE_PREFIX: string = 'links-detector';
const CACHE_VERSION: number = 1;

const getCacheName = (name: string): string => {
  return `${CACHE_PREFIX}--v${CACHE_VERSION}--${name}`;
};

const daysToSeconds = (days: number): number => {
  const secondsInDay: number = 24 * 60 * 60;
  return days * secondsInDay;
};

skipWaiting();
clientsClaim();

// @see: https://developer.mozilla.org/en-US/docs/Web/API/Request
// @see: https://developer.mozilla.org/en-US/docs/Web/API/RequestDestination

// Caching static assets.
registerRoute(
  (route) => {
    // eslint-disable-next-line no-undef
    const assetTypes: RequestDestination[] = ['image'];
    console.log('++++ YO', route);
    return assetTypes.includes(route.request.destination);
  },
  new CacheFirst({
    cacheName: getCacheName('static-assets'),
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: daysToSeconds(30),
      }),
      new CacheableResponsePlugin({ statuses: [200] }),
    ],
  }),
);

// Caching dynamic assets.
registerRoute(
  (route) => {
    // eslint-disable-next-line no-undef
    const assetTypes: RequestDestination[] = ['style', 'script', 'worker'];
    return assetTypes.includes(route.request.destination) || route.url.href.endsWith('.json');
  },
  new StaleWhileRevalidate({
    cacheName: getCacheName('dynamic-assets'),
    plugins: [
      new CacheableResponsePlugin({ statuses: [200] }),
    ],
  }),
);

// Caching models.
registerRoute(
  (route) => {
    // .bin is for TensorFlow and .gz is for Tesseract.
    return route.url.href.endsWith('.bin') || route.url.href.endsWith('.gz');
  },
  new StaleWhileRevalidate({
    cacheName: getCacheName('models'),
    plugins: [
      new CacheableResponsePlugin({ statuses: [200] }),
    ],
  }),
);

// Cache the Google Fonts stylesheets.
registerRoute(
  (route) => {
    return route.url.origin === 'https://fonts.googleapis.com';
  },
  new StaleWhileRevalidate({
    cacheName: getCacheName('google-fonts-stylesheets'),
  }),
);

// Cache the underlying font files.
registerRoute(
  (route) => {
    return route.url.origin === 'https://fonts.gstatic.com';
  },
  new CacheFirst({
    cacheName: getCacheName('google-fonts-webfonts'),
    plugins: [
      new CacheableResponsePlugin({ statuses: [200] }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: daysToSeconds(30),
      }),
    ],
  }),
);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
// const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
// registerRoute(
//   // Return false to exempt requests from being fulfilled by index.html.
//   ({ request, url }: { request: Request; url: URL }) => {
//     // If this isn't a navigation, skip.
//     if (request.mode !== 'navigate') {
//       return false;
//     }
//
//     // If this is a URL that starts with /_, skip.
//     if (url.pathname.startsWith('/_')) {
//       return false;
//     }
//
//     // If this looks like a URL for a resource, because it contains
//     // a file extension, skip.
//     if (url.pathname.match(fileExtensionRegexp)) {
//       return false;
//     }
//
//     // Return true to signal that we want to use the handler.
//     return true;
//   },
//   createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`),
// );
